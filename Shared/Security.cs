using System;
using System.Security.Cryptography;
using System.Text;

namespace Shared;

/// <summary>
///   Keycode rotator for IPC messaging. 
///   HMAC is Hash-based Message Authentication Code. It is a specific type of message authentication code (MAC) 
///   that combines a cryptographic hash function with a secret key. HMAC is widely used in various security 
///   protocols and applications, including SSL/TLS, JSON Web Tokens (JWT), and API authentication.
/// </summary>
/// <remarks>
///   For a production environment you wouldn't want this library to be public-facing. This could give a 
///   malicious user (using a tool such as Ghidra) a clue to defeat our algorithm.
/// </remarks>
public static class SecurityHelper
{
    #region [Creation]
    /// <summary>
    /// Generates a secure 4-digit numeric code based on the current UTC hour.
    /// </summary>
    /// <param name="secretKey">A secret key (string) to use for the code generation.</param>
    /// <returns>A string representing the secure numeric code.</returns>
    /// <remarks>This key *must* be shared between the code generator and the verifier.</remarks>
    public static string GenerateSecureCode4(string secretKey)
    {
        if (string.IsNullOrEmpty(secretKey))
            throw new ArgumentException("Secret key cannot be null or empty.", nameof(secretKey));

        return GenerateSecureCode10(secretKey).Substring(6);
    }

    /// <summary>
    /// Generates a secure 6-digit numeric code based on the current UTC hour.
    /// </summary>
    /// <param name="secretKey">A secret key (string) to use for the code generation.</param>
    /// <returns>A string representing the secure numeric code.</returns>
    /// <remarks>This key *must* be shared between the code generator and the verifier.</remarks>
    public static string GenerateSecureCode6(string secretKey)
    {
        if (string.IsNullOrEmpty(secretKey))
            throw new ArgumentException("Secret key cannot be null or empty.", nameof(secretKey));

        return GenerateSecureCode10(secretKey).Substring(4);
    }

    /// <summary>
    /// Generates a secure 8-digit numeric code based on the current UTC hour.
    /// </summary>
    /// <param name="secretKey">A secret key (string) to use for the code generation.</param>
    /// <returns>A string representing the secure numeric code.</returns>
    /// <remarks>This key *must* be shared between the code generator and the verifier.</remarks>
    public static string GenerateSecureCode8(string secretKey)
    {
        if (string.IsNullOrEmpty(secretKey))
            throw new ArgumentException("Secret key cannot be null or empty.", nameof(secretKey));

        return GenerateSecureCode10(secretKey).Substring(2);
    }

    /// <summary>
    /// Generates a secure 10-digit numeric code based on the current UTC hour.
    /// </summary>
    /// <param name="secretKey">A secret key (string) to use for the code generation.</param>
    /// <returns>A string representing the secure numeric code.</returns>
    /// <remarks>This key *must* be shared between the code generator and the verifier.</remarks>
    public static string GenerateSecureCode10(string secretKey)
    {
        if (string.IsNullOrEmpty(secretKey))
            throw new ArgumentException("Secret key cannot be null or empty.", nameof(secretKey));

        int utcHour = DateTime.UtcNow.Hour;

        // Combine the UTC hour with the secret key.
        string dataToHash = $"{utcHour}:{secretKey}";

        // Hash the combined data using HMACSHA256 (32 bytes).
        using (HMACSHA256 hmac = new HMACSHA256(Encoding.UTF8.GetBytes(secretKey)))
        {
            byte[] hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(dataToHash));
            // Convert the hash bytes to a numeric code. We'll take the first 10
            // bytes of the hash, convert them to an integer, and then format it
            // as a 10-digit string (padding with zeros if needed).
            long numericCode = BitConverter.ToInt64(hashBytes, 0); // Use ToInt64 for a larger range
            //numericCode ^= 0x5A5A5A5A5A; // Optional: XOR with a magic number
            var codeString = Math.Abs(numericCode % 10000000000).ToString("D10");  // Get the absolute value, modulo 10000000000, and format to 10 digits
            return codeString;
        }
    }
    #endregion

    #region [Verification]
    /// <summary>
    /// Verifies a secure 4-digit numeric code generated by <see cref="GenerateSecureCode4(string)"/>.
    /// </summary>
    /// <param name="code">The code to verify.</param>
    /// <param name="secretKey">The secret key used to generate the code. Must be the same as the key used for generation.</param>
    /// <returns>True if the code is valid (matches the generated code for the current UTC hour), false otherwise.</returns>
    public static bool VerifySecureCode4(string code, string secretKey)
    {
        if (string.IsNullOrEmpty(code) || string.IsNullOrEmpty(secretKey))
            return false; // Invalid code or secret key

        string expectedCode = GenerateSecureCode10(secretKey).Substring(6);
        return code == expectedCode;
    }

    /// <summary>
    /// Verifies a secure 6-digit numeric code generated by <see cref="GenerateSecureCode6(string)"/>.
    /// </summary>
    /// <param name="code">The code to verify.</param>
    /// <param name="secretKey">The secret key used to generate the code. Must be the same as the key used for generation.</param>
    /// <returns>True if the code is valid (matches the generated code for the current UTC hour), false otherwise.</returns>
    public static bool VerifySecureCode6(string code, string secretKey)
    {
        if (string.IsNullOrEmpty(code) || string.IsNullOrEmpty(secretKey))
            return false; // Invalid code or secret key

        string expectedCode = GenerateSecureCode10(secretKey).Substring(4);
        return code == expectedCode;
    }

    /// <summary>
    /// Verifies a secure 8-digit numeric code generated by <see cref="GenerateSecureCode8(string)"/>.
    /// </summary>
    /// <param name="code">The code to verify.</param>
    /// <param name="secretKey">The secret key used to generate the code. Must be the same as the key used for generation.</param>
    /// <returns>True if the code is valid (matches the generated code for the current UTC hour), false otherwise.</returns>
    public static bool VerifySecureCode8(string code, string secretKey)
    {
        if (string.IsNullOrEmpty(code) || string.IsNullOrEmpty(secretKey))
            return false; // Invalid code or secret key

        string expectedCode = GenerateSecureCode10(secretKey).Substring(2);
        return code == expectedCode;
    }

    /// <summary>
    /// Verifies a secure 8-digit numeric code generated by <see cref="GenerateSecureCode8(string)"/>.
    /// </summary>
    /// <param name="code">The code to verify.</param>
    /// <param name="secretKey">The secret key used to generate the code. Must be the same as the key used for generation.</param>
    /// <returns>True if the code is valid (matches the generated code for the current UTC hour), false otherwise.</returns>
    public static bool VerifySecureCode10(string code, string secretKey)
    {
        if (string.IsNullOrEmpty(code) || string.IsNullOrEmpty(secretKey))
            return false; // Invalid code or secret key

        string expectedCode = GenerateSecureCode10(secretKey);
        return code == expectedCode;
    }
    #endregion
}
